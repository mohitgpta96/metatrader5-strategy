"""
Zerodha KiteConnect data fetcher for NSE stocks.

Primary source: KiteConnect API (higher reliability, no rate-limit throttling).
Fallback:       yfinance (automatic, per-ticker, on any Kite failure).

Access token rotation:
  KiteConnect access tokens expire daily at 6 AM IST.  For unattended
  GitHub Actions runs we use TOTP-based auto-login (Option A):
    1. POST to Zerodha login endpoint with user_id + password
    2. POST OTP generated by pyotp (TOTP) to the 2FA endpoint
    3. Exchange the resulting request_token for an access_token via the
       KiteConnect generate_session() call.

  If KITE_ACCESS_TOKEN is already set in the environment (e.g. set
  manually for a short-lived run) we skip the TOTP flow entirely.

Environment variables (all optional — Kite disabled if absent):
  KITE_API_KEY        Your KiteConnect app's API key
  KITE_API_SECRET     Your KiteConnect app's API secret
  KITE_USER_ID        Zerodha client/user ID  (e.g. ZX1234)
  KITE_PASSWORD       Zerodha login password
  KITE_TOTP_SECRET    Base-32 TOTP secret from Zerodha 2FA setup
  KITE_ACCESS_TOKEN   (Optional) Pre-generated token; skips TOTP login

Usage:
  from data.fetcher_kite import fetch_stocks_kite, fetch_stock_single_kite

  # Fetch all NSE stocks defined in config/instruments.py
  data = fetch_stocks_kite()          # {yf_ticker: DataFrame}

  # Fetch a single stock
  df = fetch_stock_single_kite("RELIANCE.NS")
"""

import os
import sys
import time
import logging
from datetime import datetime, timedelta, timezone
from pathlib import Path

import pandas as pd

# ---------------------------------------------------------------------------
# Path bootstrap — allow running this module directly for testing
# ---------------------------------------------------------------------------
_HERE = Path(__file__).resolve().parent
_ROOT = _HERE.parent
if str(_ROOT) not in sys.path:
    sys.path.insert(0, str(_ROOT))

from config.settings import DATA_CACHE_DIR, HISTORY_PERIOD_DAILY
from config.instruments import ALL_STOCK_TICKERS

# ---------------------------------------------------------------------------
# Optional dependency guards
# ---------------------------------------------------------------------------
try:
    from kiteconnect import KiteConnect
    _KITE_AVAILABLE = True
except ImportError:
    _KITE_AVAILABLE = False

try:
    import pyotp
    _PYOTP_AVAILABLE = True
except ImportError:
    _PYOTP_AVAILABLE = False

try:
    import requests as _requests
    _REQUESTS_AVAILABLE = True
except ImportError:
    _REQUESTS_AVAILABLE = False

# ---------------------------------------------------------------------------
# Logging
# ---------------------------------------------------------------------------
log = logging.getLogger(__name__)
if not log.handlers:
    _h = logging.StreamHandler()
    _h.setFormatter(logging.Formatter("  [KiteFetcher] %(levelname)s: %(message)s"))
    log.addHandler(_h)
log.setLevel(logging.INFO)

# ---------------------------------------------------------------------------
# Module-level singleton cache so we only build the instruments table once
# per process run (saves one HTTP call per fetch call).
# ---------------------------------------------------------------------------
_KITE_CLIENT: "KiteConnect | None" = None
_INSTRUMENT_TOKEN_CACHE: dict[str, int] = {}   # "NSE:RELIANCE" -> 738561

# ---------------------------------------------------------------------------
# Zerodha login endpoints (unofficial but stable — used by open-source Kite
# community tools and the kiteconnect-mcp ecosystem).
# ---------------------------------------------------------------------------
_ZERODHA_LOGIN_URL = "https://kite.zerodha.com/api/login"
_ZERODHA_TWOFA_URL = "https://kite.zerodha.com/api/twofa"

# ---------------------------------------------------------------------------
# Helper: convert yfinance ticker to Kite trading symbol
# ---------------------------------------------------------------------------

def _yf_ticker_to_kite(yf_ticker: str) -> tuple[str, str]:
    """Convert a yfinance NSE ticker to a KiteConnect (exchange, trading_symbol) pair.

    Examples
    --------
    "RELIANCE.NS"  -> ("NSE", "RELIANCE")
    "M&M.NS"       -> ("NSE", "M&M")
    "BAJAJ-AUTO.NS"-> ("NSE", "BAJAJ-AUTO")
    """
    if yf_ticker.endswith(".NS"):
        symbol = yf_ticker[:-3]          # strip ".NS"
        return ("NSE", symbol)
    # Non-NSE tickers are not handled by this fetcher
    return (None, None)


# ---------------------------------------------------------------------------
# TOTP auto-login
# ---------------------------------------------------------------------------

def _get_access_token() -> str | None:
    """Return a valid KiteConnect access token.

    Resolution order:
    1. KITE_ACCESS_TOKEN env var (pre-generated, no TOTP needed)
    2. Full TOTP auto-login using KITE_USER_ID + KITE_PASSWORD +
       KITE_TOTP_SECRET + KITE_API_KEY + KITE_API_SECRET

    Returns None if required credentials are missing or login fails.
    """
    # --- Option 1: pre-provided token ---
    token = os.getenv("KITE_ACCESS_TOKEN", "").strip()
    if token:
        log.info("Using KITE_ACCESS_TOKEN from environment (skipping TOTP login).")
        return token

    # --- Option 2: TOTP auto-login ---
    if not _PYOTP_AVAILABLE:
        log.warning(
            "pyotp is not installed. Cannot perform TOTP auto-login. "
            "Install it with: pip install pyotp"
        )
        return None

    if not _REQUESTS_AVAILABLE:
        log.warning("requests library not available — cannot perform Kite login.")
        return None

    api_key    = os.getenv("KITE_API_KEY",     "").strip()
    api_secret = os.getenv("KITE_API_SECRET",  "").strip()
    user_id    = os.getenv("KITE_USER_ID",     "").strip()
    password   = os.getenv("KITE_PASSWORD",    "").strip()
    totp_secret= os.getenv("KITE_TOTP_SECRET", "").strip()

    missing = [
        name for name, val in [
            ("KITE_API_KEY",    api_key),
            ("KITE_API_SECRET", api_secret),
            ("KITE_USER_ID",    user_id),
            ("KITE_PASSWORD",   password),
            ("KITE_TOTP_SECRET",totp_secret),
        ] if not val
    ]
    if missing:
        log.warning(
            "Kite TOTP login skipped — missing env vars: %s", ", ".join(missing)
        )
        return None

    try:
        session = _requests.Session()
        session.headers.update({
            "User-Agent": (
                "Mozilla/5.0 (X11; Linux x86_64) "
                "AppleWebKit/537.36 (KHTML, like Gecko) "
                "Chrome/120.0.0.0 Safari/537.36"
            ),
            "X-Kite-Version": "3",
        })

        # Step 1: POST login credentials
        log.info("Kite login step 1: submitting user_id + password...")
        r1 = session.post(
            _ZERODHA_LOGIN_URL,
            data={"user_id": user_id, "password": password},
            timeout=15,
        )
        r1.raise_for_status()
        data1 = r1.json()
        if data1.get("status") != "success":
            log.error("Kite login step 1 failed: %s", data1.get("message", data1))
            return None

        request_id = data1["data"]["request_id"]
        log.info("Kite login step 1 OK. request_id obtained.")

        # Step 2: POST TOTP as 2FA
        totp_value = pyotp.TOTP(totp_secret).now()
        log.info("Kite login step 2: submitting TOTP (%s)...", totp_value)
        r2 = session.post(
            _ZERODHA_TWOFA_URL,
            data={
                "user_id":    user_id,
                "request_id": request_id,
                "twofa_value":totp_value,
                "twofa_type": "totp",
                "skip_session": "",
            },
            timeout=15,
        )
        r2.raise_for_status()
        data2 = r2.json()
        if data2.get("status") != "success":
            log.error("Kite login step 2 (2FA) failed: %s", data2.get("message", data2))
            return None

        log.info("Kite 2FA OK. Extracting request_token from redirect...")

        # Step 3: Fetch the Kite login URL to get request_token via redirect
        login_url = (
            f"https://kite.zerodha.com/connect/login"
            f"?api_key={api_key}&v=3"
        )
        r3 = session.get(login_url, timeout=15, allow_redirects=True)
        # The final URL contains ?request_token=<token>&...
        final_url = r3.url
        from urllib.parse import urlparse, parse_qs
        qs = parse_qs(urlparse(final_url).query)
        request_tokens = qs.get("request_token", [])
        if not request_tokens:
            # Try to extract from the last redirect in history
            for resp in reversed(r3.history):
                loc = resp.headers.get("Location", "")
                qs = parse_qs(urlparse(loc).query)
                request_tokens = qs.get("request_token", [])
                if request_tokens:
                    break
        if not request_tokens:
            log.error(
                "Could not extract request_token from redirect. Final URL: %s",
                final_url,
            )
            return None

        request_token = request_tokens[0]
        log.info("request_token obtained: %s...", request_token[:8])

        # Step 4: Exchange request_token for access_token via KiteConnect SDK
        kite_tmp = KiteConnect(api_key=api_key)
        sess = kite_tmp.generate_session(request_token, api_secret=api_secret)
        access_token = sess["access_token"]
        log.info("access_token obtained successfully (first 8 chars: %s...).", access_token[:8])
        return access_token

    except Exception as exc:
        log.error("Kite TOTP auto-login failed: %s", exc, exc_info=True)
        return None


# ---------------------------------------------------------------------------
# KiteConnect client factory
# ---------------------------------------------------------------------------

def _get_kite_client() -> "KiteConnect | None":
    """Return a cached, authenticated KiteConnect instance or None on failure."""
    global _KITE_CLIENT

    if not _KITE_AVAILABLE:
        log.warning(
            "kiteconnect package not installed. "
            "Install with: pip install kiteconnect"
        )
        return None

    if _KITE_CLIENT is not None:
        return _KITE_CLIENT

    api_key = os.getenv("KITE_API_KEY", "").strip()
    if not api_key:
        log.info("KITE_API_KEY not set — Kite fetcher disabled.")
        return None

    access_token = _get_access_token()
    if not access_token:
        log.warning("Could not obtain a valid Kite access token.")
        return None

    kite = KiteConnect(api_key=api_key)
    kite.set_access_token(access_token)

    # Quick sanity check — fetch profile (lightweight API call)
    try:
        profile = kite.profile()
        log.info(
            "KiteConnect authenticated as: %s (%s)",
            profile.get("user_name", "?"),
            profile.get("user_id", "?"),
        )
    except Exception as exc:
        log.error("KiteConnect auth verification failed: %s", exc)
        return None

    _KITE_CLIENT = kite
    return kite


# ---------------------------------------------------------------------------
# Instrument token lookup
# ---------------------------------------------------------------------------

def _get_instrument_token(kite: "KiteConnect", trading_symbol: str, exchange: str = "NSE") -> int | None:
    """Look up the numeric instrument token for an NSE trading symbol.

    The instruments list is fetched once and cached in-memory for the
    lifetime of the process.

    Parameters
    ----------
    kite:           Authenticated KiteConnect instance.
    trading_symbol: e.g. "RELIANCE", "M&M", "BAJAJ-AUTO"
    exchange:       "NSE" (default)

    Returns
    -------
    int instrument token, or None if not found.
    """
    cache_key = f"{exchange}:{trading_symbol}"
    if cache_key in _INSTRUMENT_TOKEN_CACHE:
        return _INSTRUMENT_TOKEN_CACHE[cache_key]

    # Populate cache from full instruments dump (one HTTP call, ~1 MB)
    if not _INSTRUMENT_TOKEN_CACHE:
        log.info("Fetching full Kite instruments list (NSE)...")
        try:
            instruments = kite.instruments(exchange=exchange)
            for inst in instruments:
                key = f"{inst['exchange']}:{inst['tradingsymbol']}"
                _INSTRUMENT_TOKEN_CACHE[key] = int(inst["instrument_token"])
            log.info(
                "Loaded %d %s instruments into token cache.",
                len(instruments), exchange,
            )
        except Exception as exc:
            log.error("Failed to fetch instruments list from Kite: %s", exc)
            return None

    token = _INSTRUMENT_TOKEN_CACHE.get(cache_key)
    if token is None:
        log.warning("Instrument token not found for %s:%s", exchange, trading_symbol)
    return token


# ---------------------------------------------------------------------------
# yfinance fallback (mirrors logic in fetcher.py)
# ---------------------------------------------------------------------------

def _fetch_yfinance_fallback(yf_ticker: str, interval: str = "1d") -> pd.DataFrame | None:
    """Fetch a single NSE stock via yfinance (fallback path)."""
    try:
        import yfinance as yf
        period = HISTORY_PERIOD_DAILY  # "1y" from settings
        df = yf.download(
            yf_ticker,
            period=period,
            interval=interval,
            progress=False,
            auto_adjust=True,
        )
        if df.empty:
            log.warning("yfinance returned no data for %s", yf_ticker)
            return None

        # Flatten MultiIndex if present (yfinance >=0.2 multi-ticker downloads)
        if isinstance(df.columns, pd.MultiIndex):
            df.columns = df.columns.get_level_values(0)

        df.columns = [c.title() for c in df.columns]
        return df
    except Exception as exc:
        log.error("yfinance fallback failed for %s: %s", yf_ticker, exc)
        return None


# ---------------------------------------------------------------------------
# Core Kite fetch logic
# ---------------------------------------------------------------------------

def _kite_to_dataframe(records: list[dict]) -> pd.DataFrame | None:
    """Convert the list of dicts returned by kite.historical_data() to a DataFrame.

    KiteConnect returns records like:
        [{"date": datetime(...), "open": 1234.0, "high": ..., "low": ...,
          "close": ..., "volume": 123456}, ...]

    We want: DatetimeIndex, columns [Open, High, Low, Close, Volume] (Title case).
    """
    if not records:
        return None

    df = pd.DataFrame(records)
    df = df.rename(columns={
        "date":   "Date",
        "open":   "Open",
        "high":   "High",
        "low":    "Low",
        "close":  "Close",
        "volume": "Volume",
    })

    # Drop any extra columns KiteConnect may return (e.g. "oi")
    keep = [c for c in ["Date", "Open", "High", "Low", "Close", "Volume"] if c in df.columns]
    df = df[keep].copy()

    # Build DatetimeIndex
    df["Date"] = pd.to_datetime(df["Date"])
    # KiteConnect returns timezone-aware datetimes (Asia/Kolkata).
    # Normalize to UTC-naive (tz-strip) to be consistent with yfinance output.
    if hasattr(df["Date"].dt, "tz") and df["Date"].dt.tz is not None:
        df["Date"] = df["Date"].dt.tz_localize(None)

    df = df.set_index("Date")
    df = df.sort_index()
    df = df.dropna(how="all")
    return df if not df.empty else None


def _cache_dataframe(df: pd.DataFrame, yf_ticker: str, interval: str) -> None:
    """Save a DataFrame to the project's CSV cache (same convention as fetcher.py)."""
    try:
        safe_name = (
            yf_ticker
            .replace("=", "_")
            .replace("^", "IDX_")
            .replace(".", "_")
        )
        cache_path = DATA_CACHE_DIR / f"{safe_name}_{interval}.csv"
        df.to_csv(cache_path)
    except Exception as exc:
        log.warning("Cache write failed for %s: %s", yf_ticker, exc)


# ---------------------------------------------------------------------------
# Public API
# ---------------------------------------------------------------------------

def fetch_stock_single_kite(yf_ticker: str, interval: str = "1d") -> pd.DataFrame | None:
    """Fetch OHLCV data for a single NSE stock, with yfinance fallback.

    Parameters
    ----------
    yf_ticker:  yfinance-style NSE ticker, e.g. "RELIANCE.NS"
    interval:   "1d" (daily) — only daily is supported via this fetcher;
                other intervals will fall straight through to yfinance.

    Returns
    -------
    pandas DataFrame with columns [Open, High, Low, Close, Volume] and a
    DatetimeIndex, or None if both Kite and yfinance fail.

    The fetched data is automatically cached to DATA_CACHE_DIR as CSV.
    """
    exchange, trading_symbol = _yf_ticker_to_kite(yf_ticker)
    if exchange is None:
        # Not an NSE ticker — use yfinance directly
        log.info("%s is not an NSE ticker; using yfinance directly.", yf_ticker)
        return _fetch_yfinance_fallback(yf_ticker, interval)

    # Only "day" interval is mapped here; intraday would need different period logic
    kite_interval_map = {"1d": "day", "1D": "day"}
    kite_interval = kite_interval_map.get(interval)
    if kite_interval is None:
        log.info(
            "Interval '%s' not supported by Kite daily fetcher for %s; "
            "falling back to yfinance.",
            interval, yf_ticker,
        )
        return _fetch_yfinance_fallback(yf_ticker, interval)

    # ---- Try Kite ----
    kite = _get_kite_client()
    if kite is not None:
        try:
            token = _get_instrument_token(kite, trading_symbol, exchange=exchange)
            if token is not None:
                to_date   = datetime.now(timezone.utc).replace(
                    hour=0, minute=0, second=0, microsecond=0
                )
                from_date = to_date - timedelta(days=365)  # ~1 year

                log.info(
                    "Fetching %s:%s via Kite (token %d)...",
                    exchange, trading_symbol, token,
                )
                records = kite.historical_data(
                    instrument_token=token,
                    from_date=from_date.strftime("%Y-%m-%d"),
                    to_date=to_date.strftime("%Y-%m-%d"),
                    interval=kite_interval,
                    continuous=False,
                    oi=False,
                )
                df = _kite_to_dataframe(records)
                if df is not None and not df.empty:
                    _cache_dataframe(df, yf_ticker, interval)
                    log.info(
                        "Kite OK: %s — %d candles (%s → %s)",
                        yf_ticker,
                        len(df),
                        df.index[0].date(),
                        df.index[-1].date(),
                    )
                    return df
                else:
                    log.warning(
                        "Kite returned empty data for %s — falling back to yfinance.",
                        yf_ticker,
                    )
        except Exception as exc:
            log.warning(
                "Kite fetch failed for %s (%s): %s — falling back to yfinance.",
                yf_ticker, trading_symbol, exc,
            )
    else:
        log.debug("Kite client unavailable — using yfinance for %s.", yf_ticker)

    # ---- Fallback: yfinance ----
    log.info("yfinance fallback: %s", yf_ticker)
    df = _fetch_yfinance_fallback(yf_ticker, interval)
    if df is not None and not df.empty:
        _cache_dataframe(df, yf_ticker, interval)
    return df


def fetch_stocks_kite(
    tickers: list[str] | None = None,
    interval: str = "1d",
) -> dict[str, pd.DataFrame]:
    """Fetch OHLCV data for a list of NSE stocks (Kite primary, yfinance fallback).

    Parameters
    ----------
    tickers:    List of yfinance-style NSE tickers, e.g. ["RELIANCE.NS", "TCS.NS"].
                Defaults to ALL_STOCK_TICKERS from config/instruments.py.
    interval:   Data interval ("1d" recommended for NSE stocks).

    Returns
    -------
    dict mapping yf_ticker -> DataFrame.  Tickers for which both Kite and
    yfinance fail are silently excluded from the result.
    """
    if tickers is None:
        tickers = ALL_STOCK_TICKERS

    results: dict[str, pd.DataFrame] = {}

    # Pre-warm the Kite client and instrument token cache once before the loop.
    # This avoids repeated login attempts (which would always fail after the first
    # if credentials are wrong).
    kite = _get_kite_client()
    if kite is not None:
        # Pre-fetch the full NSE instruments list so _get_instrument_token()
        # uses the in-process cache from here on out.
        _get_instrument_token(kite, "__warmup__", exchange="NSE")
        log.info(
            "Kite client ready. Will fetch %d tickers via KiteConnect + yfinance fallback.",
            len(tickers),
        )
    else:
        log.info(
            "Kite client not available. Fetching %d tickers via yfinance only.",
            len(tickers),
        )

    total = len(tickers)
    for idx, ticker in enumerate(tickers, start=1):
        log.info("[%d/%d] %s", idx, total, ticker)
        df = fetch_stock_single_kite(ticker, interval=interval)
        if df is not None:
            results[ticker] = df
        # Small polite delay to avoid hammering the API
        if kite is not None:
            time.sleep(0.2)

    kite_count = sum(
        1 for t in results
        # We can't distinguish source here — just report total success
    )
    log.info(
        "fetch_stocks_kite complete: %d/%d tickers fetched successfully.",
        len(results), total,
    )
    return results


# ---------------------------------------------------------------------------
# Cache reader (mirrors fetcher.py)
# ---------------------------------------------------------------------------

def load_cached(ticker: str, interval: str = "1d") -> pd.DataFrame | None:
    """Load previously cached data from CSV.  Same convention as fetcher.py."""
    safe_name = (
        ticker
        .replace("=", "_")
        .replace("^", "IDX_")
        .replace(".", "_")
    )
    cache_path = DATA_CACHE_DIR / f"{safe_name}_{interval}.csv"
    if cache_path.exists():
        df = pd.read_csv(cache_path, index_col=0, parse_dates=True)
        return df
    return None


# ---------------------------------------------------------------------------
# Quick smoke-test (run directly: python data/fetcher_kite.py)
# ---------------------------------------------------------------------------

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    print("=" * 60)
    print("KiteFetcher smoke test")
    print("=" * 60)

    test_tickers = ["RELIANCE.NS", "TCS.NS", "HDFCBANK.NS"]
    for t in test_tickers:
        print(f"\nFetching {t}...")
        df = fetch_stock_single_kite(t)
        if df is not None:
            print(f"  OK — {len(df)} candles | last close: {df['Close'].iloc[-1]:.2f}")
            print(f"  Columns: {list(df.columns)}")
            print(f"  Date range: {df.index[0].date()} → {df.index[-1].date()}")
        else:
            print(f"  FAILED — no data returned")
